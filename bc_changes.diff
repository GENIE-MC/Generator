diff --git a/config/EventGenerator.xml b/config/EventGenerator.xml
index 5fe64420a..9786fff8d 100644
--- a/config/EventGenerator.xml
+++ b/config/EventGenerator.xml
@@ -455,12 +455,13 @@ XSecModel                   alg     Yes  Cross section model used at the thread
 
   <param_set name="NUE-EL">
      <param type="string" name="VldContext"> </param>
-     <param type="int"    name="NModules">   5                                          </param>
+     <param type="int"    name="NModules">   6                                          </param>
      <param type="alg"    name="Module-0">   genie::InitialStateAppender/Default        </param>
      <param type="alg"    name="Module-1">   genie::VertexGenerator/Default             </param>
-     <param type="alg"    name="Module-2">   genie::NuEKinematicsGenerator/Default      </param>
-     <param type="alg"    name="Module-3">   genie::NuEPrimaryLeptonGenerator/Default   </param>
-     <param type="alg"    name="Module-4">   genie::NuETargetRemnantGenerator/Default   </param>
+     <param type="alg"    name="Module-2">   genie::ElectronVelocity/Default            </param>
+     <param type="alg"    name="Module-3">   genie::NuEKinematicsGenerator/Default      </param>
+     <param type="alg"    name="Module-4">   genie::NuEPrimaryLeptonGenerator/Default   </param>
+     <param type="alg"    name="Module-5">   genie::NuETargetRemnantGenerator/Default   </param>
      <param type="alg"    name="ILstGen">    genie::NuEInteractionListGenerator/NUE-EL  </param>
   </param_set>
 
diff --git a/config/master_config.xml b/config/master_config.xml
index 65775c665..4ef831bee 100644
--- a/config/master_config.xml
+++ b/config/master_config.xml
@@ -5,6 +5,7 @@
    <!-- ****** CONFIGURATION FOR EVENT GENERATION MODULES ****** -->
    <config alg="genie::EventGenerator">                  EventGenerator.xml                  </config>
    <config alg="genie::FermiMover">                      FermiMover.xml                      </config>
+   <config alg="genie::ElectronVelocity">                ElectronVelocity.xml                </config>
    <config alg="genie::HadronTransporter">               HadronTransporter.xml               </config>
    <config alg="genie::HAIntranuke">                     HAIntranuke.xml                     </config>
    <config alg="genie::HAIntranuke2018">                 HAIntranuke2018.xml                 </config>
diff --git a/src/Framework/Interaction/InitialState.cxx b/src/Framework/Interaction/InitialState.cxx
index d00a29646..269188824 100644
--- a/src/Framework/Interaction/InitialState.cxx
+++ b/src/Framework/Interaction/InitialState.cxx
@@ -316,6 +316,26 @@ TLorentzVector * InitialState::GetTgtP4(RefFrame_t ref_frame) const
              return p4;
              break;
        }
+       //------------------ STRUCK ELECTRON REST FRAME:
+       case (kRfHitElRest) :
+       {
+             // make sure that 'struck electron' properties were set in
+             // the electron target object
+             assert(fTgt->HitEleIsSet());
+             TLorentzVector * pele4 = fTgt->HitEleP4Ptr();
+
+             // compute velocity vector (px/E, py/E, pz/E)
+             double bx = pele4->Px() / pele4->Energy();
+             double by = pele4->Py() / pele4->Energy();
+             double bz = pele4->Pz() / pele4->Energy();
+
+             // BOOST
+             TLorentzVector * p4 = new TLorentzVector(*fTgtP4);
+             p4->Boost(-bx,-by,-bz);
+
+             return p4;
+             break;
+       }
        default:
              LOG("Interaction", pERROR) << "Uknown reference frame";
   }
@@ -374,6 +394,32 @@ TLorentzVector * InitialState::GetProbeP4(RefFrame_t ref_frame) const
 
              break;
        }
+       //----------------- STRUCK ELECTRON REST FRAME
+       case (kRfHitElRest) :
+       {
+        //Ensure target is electron
+        //assert(fTgt->Pdg() == 11);
+        assert( fTgt->HitEleP4Ptr() != 0 );
+
+        //
+        TLorentzVector * pele4 = fTgt->HitEleP4Ptr();
+
+        // compute velocity vector (px/E, py/E, pz/E)
+
+        double bx = pele4->Px() / pele4->Energy();
+        double by = pele4->Py() / pele4->Energy();
+        double bz = pele4->Pz() / pele4->Energy();
+
+        // BOOST
+
+        TLorentzVector * p4 = new TLorentzVector(*fProbeP4);
+
+        p4->Boost(-bx,-by,-bz);
+
+        return p4;
+
+        break;
+       }
        default:
 
              LOG("Interaction", pERROR) << "Uknown reference frame";
diff --git a/src/Framework/Interaction/InitialState.h b/src/Framework/Interaction/InitialState.h
index ea63c3498..e069a2697 100644
--- a/src/Framework/Interaction/InitialState.h
+++ b/src/Framework/Interaction/InitialState.h
@@ -67,6 +67,7 @@ public:
   Target *         TgtPtr     (void) const { return  fTgt; }
   TLorentzVector * GetTgtP4   (RefFrame_t rf = kRfLab) const;
   TLorentzVector * GetProbeP4 (RefFrame_t rf = kRfHitNucRest) const;
+  //TLorentzVector * GetProbeEleP4 (RefFrame_t rf = kRfHitEleRest) const;
   double           ProbeE     (RefFrame_t rf) const;
   double           CMEnergy   () const; ///< centre-of-mass energy (sqrt s)
 
diff --git a/src/Framework/Interaction/Target.cxx b/src/Framework/Interaction/Target.cxx
index 704a40908..d49cc625c 100644
--- a/src/Framework/Interaction/Target.cxx
+++ b/src/Framework/Interaction/Target.cxx
@@ -80,7 +80,8 @@ fA(0),
 fTgtPDG(0),
 fHitNucPDG(0),
 fHitSeaQrk(false),
-fHitNucP4(0)
+fHitNucP4(0),
+fHitEleP4(0)
 {
 
 }
@@ -105,12 +106,14 @@ void Target::Init(void)
   fHitQrkPDG = 0;
   fHitSeaQrk = false;
   fHitNucP4  = new TLorentzVector(0,0,0,kNucleonMass);
+  fHitEleP4  = new TLorentzVector(0,0,0,kElectronMass);
   fHitNucRad = 0.;
 }
 //___________________________________________________________________________
 void Target::CleanUp(void)
 {
   delete fHitNucP4;
+  delete fHitEleP4;
 }
 //___________________________________________________________________________
 void Target::Copy(const Target & tgt)
@@ -144,6 +147,22 @@ void Target::Copy(const Target & tgt)
      // a nucleon (p or n) or a di-nucleon cluster (p+p, p+n, n+n)
      this->ForceHitNucValidity();
   }
+  if (fTgtPDG == 11){
+    const TLorentzVector& p4 = *(tgt.fHitEleP4);
+
+    fHitEleP4->SetX(p4.X());
+    fHitEleP4->SetY(p4.Y());
+    fHitEleP4->SetZ(p4.Z());
+    fHitEleP4->SetT(p4.T());
+
+    // look-up the nucleus in the isotopes chart
+    //this->ForceNucleusValidity();
+
+    //Make sure hit target is electron
+    //this->ForceHitEleValidity();
+
+
+  }
 }
 //___________________________________________________________________________
 void Target::SetId(int pdgc)
@@ -192,6 +211,12 @@ void Target::SetHitNucP4(const TLorentzVector & p4)
   fHitNucP4 = new TLorentzVector(p4);
 }
 //___________________________________________________________________________
+void Target::SetHitEleP4(const TLorentzVector & p4)
+{
+  if(fHitEleP4) delete fHitEleP4;
+  fHitEleP4 = new TLorentzVector(p4);
+}
+//___________________________________________________________________________
 void Target::SetHitSeaQrk(bool tf)
 {
   fHitSeaQrk = tf;
@@ -254,6 +279,16 @@ TLorentzVector * Target::HitNucP4Ptr(void) const
   return fHitNucP4;
 }
 //___________________________________________________________________________
+TLorentzVector * Target::HitEleP4Ptr(void) const
+{
+  if(!fHitEleP4) {
+    LOG("Target", pWARN) << "Returning NULL struck electron 4-momentum";
+    return 0;
+  }
+
+  return fHitEleP4;
+}
+//___________________________________________________________________________
 bool Target::IsFreeNucleon(void) const
 {
   return (fA == 1 && (fZ == 0 || fZ == 1));
@@ -264,6 +299,11 @@ bool Target::IsProton(void) const
   return (fA == 1 && fZ == 1);
 }
 //___________________________________________________________________________
+bool Target::IsElectron(void) const
+{
+  return (fTgtPDG == 11);
+}
+//___________________________________________________________________________
 bool Target::IsNeutron(void) const
 {
   return (fA == 1 && fZ == 0);
@@ -289,6 +329,13 @@ bool Target::HitNucIsSet(void) const
   return ok;
 }
 //___________________________________________________________________________
+bool Target::HitEleIsSet(void) const
+{
+  bool ok = fTgtPDG == 11;
+
+  return ok;
+}
+//___________________________________________________________________________
 bool Target::HitQrkIsSet(void) const
 {
   return (
@@ -347,6 +394,15 @@ bool Target::IsOddOdd(void) const
   return false;
 }
 //___________________________________________________________________________
+// bool Target::ForceHitEleValidity(void)
+// {
+// // resets the struck electron pdg-code if it is found not to be a valid one
+
+//   bool valid = fHitElePDG == 11;
+
+//   return valid;
+// }
+//___________________________________________________________________________
 bool Target::ForceHitNucValidity(void)
 {
 // resets the struck nucleon pdg-code if it is found not to be a valid one
diff --git a/src/Framework/Interaction/Target.h b/src/Framework/Interaction/Target.h
index 3ce0abccd..606897b8b 100644
--- a/src/Framework/Interaction/Target.h
+++ b/src/Framework/Interaction/Target.h
@@ -58,6 +58,7 @@ public:
   void SetId                  (int Z, int A);
   void SetHitNucPdg           (int pdgc);
   void SetHitNucP4            (const TLorentzVector & p4);
+  void SetHitEleP4            (const TLorentzVector & p4);
   void SetHitNucPosition        (double r);
   void SetHitQrkPdg           (int pdgc);
   void SetHitSeaQrk           (bool tf);
@@ -73,11 +74,13 @@ public:
   double Charge         (void) const;
   bool   IsFreeNucleon  (void) const;
   bool   IsProton       (void) const;
+  bool   IsElectron     (void) const;
   bool   IsNeutron      (void) const;
   bool   IsNucleus      (void) const;
   bool   IsParticle     (void) const;
   bool   IsValidNucleus (void) const;
   bool   HitNucIsSet    (void) const;
+  bool   HitEleIsSet    (void) const;
   bool   HitQrkIsSet    (void) const;
   bool   HitSeaQrk      (void) const;
   bool   IsEvenEven     (void) const;
@@ -90,6 +93,8 @@ public:
 
   const TLorentzVector & HitNucP4    (void) const { return *this->HitNucP4Ptr(); }
   TLorentzVector *       HitNucP4Ptr (void) const;
+  const TLorentzVector & HitEleP4    (void) const { return *this->HitEleP4Ptr(); }
+  TLorentzVector *       HitEleP4Ptr (void) const;
 
   //-- Copy, reset, compare, print itself and build string code
   void   Reset    (void);
@@ -121,6 +126,7 @@ private:
   int  fHitQrkPDG;            ///< hit quark PDG code
   bool fHitSeaQrk;            ///< hit quark from sea?
   TLorentzVector * fHitNucP4; ///< hit nucleon 4p
+  TLorentzVector * fHitEleP4; ///< hit electron 4p
   double fHitNucRad;          ///< hit nucleon position
 
 ClassDef(Target,2)
diff --git a/src/Physics/NuElectron/EventGen/NuEKinematicsGenerator.cxx b/src/Physics/NuElectron/EventGen/NuEKinematicsGenerator.cxx
index af9eb2cf2..be7563afd 100644
--- a/src/Physics/NuElectron/EventGen/NuEKinematicsGenerator.cxx
+++ b/src/Physics/NuElectron/EventGen/NuEKinematicsGenerator.cxx
@@ -210,10 +210,11 @@ double NuEKinematicsGenerator::ComputeMaxXSec(
 double NuEKinematicsGenerator::Energy(const Interaction * interaction) const
 {
 // Override the base class Energy() method to cache the max xsec for the
-// neutrino energy in the LAB rather than in the hit nucleon rest frame.
+// neutrino energy in the electron rest frame.
 
   const InitialState & init_state = interaction->InitState();
-  double E = init_state.ProbeE(kRfLab);
+  //double E = init_state.ProbeE(kRfLab);
+  double E = init_state.ProbeE(kRfHitElRest); //
   return E;
 }
 //___________________________________________________________________________
diff --git a/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.cxx b/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.cxx
index 741dc127f..8607fe1af 100644
--- a/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.cxx
+++ b/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.cxx
@@ -47,7 +47,15 @@ void NuEPrimaryLeptonGenerator::ProcessEventRecord(GHepRecord * evrec) const
 // This method generates the final state primary lepton for NuE events
 
   Interaction * interaction = evrec->Summary();
-  const InitialState & init_state = interaction->InitState();
+
+  // Boost vector for [LAB] <-> [Electron Rest Frame] transforms
+  TVector3 beta = this->EleRestFrame2Lab(evrec);
+
+  // Neutrino 4p
+  TLorentzVector * p4v = evrec->Probe()->GetP4(); // v 4p @ LAB
+  p4v->Boost(-1.*beta);                           // v 4p @ Nucleon rest frame
+
+  //const InitialState & init_state = interaction->InitState();
 
   // Get selected kinematics
   double y = interaction->Kine().y(true);
@@ -58,7 +66,7 @@ void NuEPrimaryLeptonGenerator::ProcessEventRecord(GHepRecord * evrec) const
   assert(pdgc!=0);
 
   // Compute the neutrino and muon energy
-  double Ev  = init_state.ProbeE(kRfLab);
+  double Ev  = p4v->E();
   double El  = (1-y)*Ev;
 
   LOG("LeptonicVertex", pINFO)
@@ -119,3 +127,17 @@ void NuEPrimaryLeptonGenerator::ProcessEventRecord(GHepRecord * evrec) const
   this->SetPolarization(evrec);
 }
 //___________________________________________________________________________
+TVector3 NuEPrimaryLeptonGenerator::EleRestFrame2Lab(GHepRecord * evrec) const
+{
+// Velocity for an active Lorentz transform taking the final state primary
+// lepton from the [electron rest frame] --> [LAB]
+
+  Interaction * interaction = evrec->Summary();
+  const InitialState & init_state = interaction->InitState();
+
+  const TLorentzVector & pele4 = init_state.Tgt().HitEleP4(); //[@LAB]
+  TVector3 beta = pele4.BoostVector();
+
+  return beta;
+}
+//___________________________________________________________________________
diff --git a/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.h b/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.h
index 874b2405f..48e9c5a72 100644
--- a/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.h
+++ b/src/Physics/NuElectron/EventGen/NuEPrimaryLeptonGenerator.h
@@ -32,6 +32,8 @@ public :
 
   //-- implement the EventRecordVisitorI interface
   void ProcessEventRecord(GHepRecord * event_rec) const;
+
+  virtual TVector3 EleRestFrame2Lab (GHepRecord * ev) const;
 };
 
 }      // genie namespace
diff --git a/src/Physics/NuElectron/XSection/NuElectronPXSec.cxx b/src/Physics/NuElectron/XSection/NuElectronPXSec.cxx
index 88d65161c..797d4f969 100644
--- a/src/Physics/NuElectron/XSection/NuElectronPXSec.cxx
+++ b/src/Physics/NuElectron/XSection/NuElectronPXSec.cxx
@@ -18,6 +18,7 @@
 #include "Framework/Messenger/Messenger.h"
 #include "Framework/ParticleData/PDGUtils.h"
 #include "Framework/Utils/KineUtils.h"
+#include "Physics/NuclearState/ElectronVelocity.h"
 
 using namespace genie;
 using namespace genie::constants;
@@ -52,7 +53,7 @@ double NuElectronPXSec::XSec(
   const Kinematics &   kinematics = interaction -> Kine();
   const ProcessInfo &  proc_info  = interaction -> ProcInfo();
 
-  double Ev = init_state.ProbeE(kRfLab);
+  double Ev = init_state.ProbeE(kRfHitElRest);
   double me = kElectronMass;
   double y  = kinematics.y();
   double A  = kGF2*2*me*Ev/kPi;
@@ -134,8 +135,52 @@ double NuElectronPXSec::XSec(
 //____________________________________________________________________________
 double NuElectronPXSec::Integral(const Interaction * interaction) const
 {
-  double xsec = fXSecIntegrator->Integrate(this,interaction);
-  return xsec;
+  //Get initial state nucleus, necessary for Z
+  Interaction in_curr(*interaction);
+  // hit target
+  Target * tgt = in_curr.InitState().TgtPtr();
+  int Z = tgt->Z(); //Get Z value
+
+
+  //Generate random velocities inherited from ElectronVelocity.cxx
+  const int N = 2000; 
+  // VertexGenerator for generating a position before generating
+  // each electron
+  //VertexGenerator * vg = new VertexGenerator();
+  //vg->Configure("Default");
+
+  double xsec_sum = 0;
+  for (int iele=0;iele<N;iele++){
+    //Does this work for getting the electron position?
+    //TVector3 elepos = vg->GenerateVertex(&in_curr,tgt->A());
+
+    //Generate electron
+    TLorentzVector * p4 = tgt->HitEleP4Ptr(); //Initialize 4 momentum pointer
+    TVector3 p3; //Initialize momentum vector
+    float velocity = ElectronVelocity().random_bohr_velocity(Z,true); //Get random bohr velocity
+    vector<float> v0{velocity/sqrt(3),velocity/sqrt(3),velocity/sqrt(3)}; //Make velocity vector
+    float gamma = 1/sqrt(1-velocity*velocity); //Get boost
+    vector<float> vf = ElectronVelocity().randomize_velocity(v0); //Randomize direction of velocity
+    //Set 3 momentum
+    float me = kElectronMass; //GeV
+    p3.SetX(me*gamma*vf[0]);
+    p3.SetY(me*gamma*vf[1]);
+    p3.SetZ(me*gamma*vf[2]);
+    //Calculate energy
+    double PF2 = p3.Mag2(); //Magnitude of momentum 2
+    double EN = sqrt(PF2+me*me);
+    //-- update the electron 4p
+    p4->SetPx( p3.Px() );
+    p4->SetPy( p3.Py() );
+    p4->SetPz( p3.Pz() );
+    p4->SetE ( EN      );
+    //std::cout<<"******"<<p3.Px()<<"*****"<<p3.Py()<<"*****"<<p3.Pz()<<std::endl;
+    double xsec = fXSecIntegrator->Integrate(this,&in_curr);
+    xsec_sum+=xsec;
+  }
+  double xsec_avg = xsec_sum/N;
+  
+  return xsec_avg;
 }
 //____________________________________________________________________________
 bool NuElectronPXSec::ValidProcess(const Interaction * interaction) const
diff --git a/src/Physics/NuElectron/XSection/NuElectronPXSec.h b/src/Physics/NuElectron/XSection/NuElectronPXSec.h
index 618d2fbd8..8f0c32b3f 100644
--- a/src/Physics/NuElectron/XSection/NuElectronPXSec.h
+++ b/src/Physics/NuElectron/XSection/NuElectronPXSec.h
@@ -27,8 +27,11 @@
 
 #ifndef _NU_ELECTRON_PARTIAL_XSEC_H_
 #define _NU_ELECTRON_PARTIAL_XSEC_H_
+//#ifndef _ELECTRON_VELOCITY_H_
+//#define _ELECTRON_VELOCITY_H_
 
 #include "Framework/EventGen/XSecAlgorithmI.h"
+//#include "Physics/NuclearState/ElectronVelocity.h"
 
 namespace genie {
 
diff --git a/src/Physics/NuclearState/LinkDef.h b/src/Physics/NuclearState/LinkDef.h
index c9207f1ca..c1c1e0151 100644
--- a/src/Physics/NuclearState/LinkDef.h
+++ b/src/Physics/NuclearState/LinkDef.h
@@ -26,4 +26,6 @@
 #pragma link C++ class genie::SecondNucleonEmissionI;
 #pragma link C++ class genie::SpectralFunction2p2h;
 
+#pragma link C++ class genie::ElectronVelocity;
+
 #endif
