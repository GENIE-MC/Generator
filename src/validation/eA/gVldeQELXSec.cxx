//____________________________________________________________________________________________ 
/*!

\program gvld_e_qel_xsec

\brief   Compares GENIE with quasi-elastic electron scattering data.

         The data come from the Quasielastic Electron Nucleus Scattering Data
         Archive maintained by Donal Day:
         http://http://faculty.virginia.edu/qes-archive/
         See also O. Benhar, D. Day and I. Sick, Rev.Mod.Phys.80, 189, 2008
         A local copy of the data may be found in:
         $GENIE/data/validation/eA/xsec/differential/qe
         The archive contains ~19k data points.

         Syntax:
           gvld_e_qel_xsec 
                 [-g input_file_list] 
                 [-d data_archive]
                 [-s datasets_to_plot]
                 [--use-toy-model]
                 [--fit-qe-peak-with-gaussian]

         Options:

           [] Denotes an optional argument.

           -d Full path to the electron QE archive.
              By default, will pick the one at:
              $GENIE/data/validation/eA/xsec/differential/qe/eQE.root

           -s Info on which datasets to plot. 
              By default, will pick the one at:
              $GENIE/data/validation/eA/xsec/differential/qe/datasets.txt

           -g An XML file with GENIE inputs (cross sections and event samples).
              If not set, only data -no GENIE predictions- will be displayed.
              Multiple models can be included in the input file, each identified
              by a "name" (all model predictions will be overlayed).
              For info on the XML file format see the GSimFiles class documentation.
              Notes:
              - The inputs for this benchmark test are prepared by the scipt
                submit_eA_xsec_validation_mc_jobs.pl
              - The input event files are `gst' summary ntuples generated by
                GENIE gntpc utility.

           --use-toy-model
              Use this option to construct a toy model.
              A toy model replaces one or more of the predicted GENIE \nu=E-E' spectrum
              components (eg quasi-elastic, meson-exchange, resonance etc) with empirical
              parameterizations based on the same data shown in each data/MC comparison.
              This allows models of different spectrum components to be tuned independently.
              The toy model is constructed using options specified below.

           --fit-qe-peak-with-gaussian
              Replace GENIE QE component with a gaussian fit of the data around the QE peak.

\author  Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
         University of Liverpool & STFC Rutherford Appleton Lab

\created Oct 16, 2009 

Important revisions after version 2.0.0 :
 @ Sep 27, 2012 - we have 2 places for data, program now can access either
         make beam energy range a little larger to use more datasets
         make angle and nu settings correct for wide range of ep data
 
\cpright Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
         For the full text of the license visit http://copyright.genie-mc.org
         or see $GENIE/LICENSE
*/
//____________________________________________________________________________________________

#include <cstdlib>
#include <cassert>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>

#include <TSystem.h>
#include <TStyle.h>
#include <TFile.h>
#include <TDirectory.h>
#include <TGraph.h>
#include <TGraphErrors.h>
#include <TF1.h>
#include <TPostScript.h>
#include <TLatex.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TMath.h>
#include <TCanvas.h>
#include <TPavesText.h>
#include <TText.h>
#include <TLegend.h>
#include <TBox.h>

#include "Conventions/Constants.h"
#include "Conventions/Units.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGCodes.h"
#include "PDG/PDGLibrary.h"
#include "Utils/CmdLnArgParser.h"
#include "Utils/GSimFiles.h"
#include "Utils/SystemUtils.h"
#include "Utils/Style.h"

using std::ostringstream;
using std::ifstream;
using std::string;
using std::vector;

using namespace genie;
using namespace genie::constants;

//.................................................................................
// Utility class to hold info on plotted datasets
//
class eQEDataSetDescription
{
public:
  eQEDataSetDescription(
     int tgtpdg, string citation, double E, double theta) :
    fTgtPdg   (tgtpdg), 
    fCitation (citation), 
    fE        (E), 
    fTheta    (theta)
  {   
  }
  eQEDataSetDescription() 
  {   
  }
  int    TgtPdg   (void) const { return fTgtPdg; }
  int    TgtZ     (void) const { return pdg::IonPdgCodeToZ(fTgtPdg); }
  int    TgtA     (void) const { return pdg::IonPdgCodeToA(fTgtPdg); }
  string TgtName  (void) const { 
    if(fTgtPdg == 1000010010) return "1H";
    if(fTgtPdg == 1000010020) return "2D";
    if(fTgtPdg == 1000010030) return "3H";
    if(fTgtPdg == 1000020030) return "3He";
    if(fTgtPdg == 1000020040) return "4He";
    if(fTgtPdg == 1000060120) return "12C";
    if(fTgtPdg == 1000080160) return "16O";
    if(fTgtPdg == 1000130270) return "27Al";
    if(fTgtPdg == 1000200400) return "40Ca";
    if(fTgtPdg == 1000200480) return "48Ca";
    if(fTgtPdg == 1000260560) return "56Fe";
    if(fTgtPdg == 1000791970) return "197Au";
    if(fTgtPdg == 1000822080) return "208Pb";
    if(fTgtPdg == 1000922380) return "238U";
    return "Other";
  }
  string Citation (void) const { return fCitation; }
  double E        (void) const { return fE; }
  double Theta    (void) const { return fTheta; }
  string LabelTeX (void) const { 
    //label in ROOT TeX format
    ostringstream label;
    label << this->TgtName() << "(e,e^{'}) ";
    label << "E = " << fE << " GeV, ";
    label << "#theta = " << fTheta << "^{o}";
    //label << " [" << fCitation << "]";
    return label.str();
  }
  string LabelCompact (void) const { 
    //compact label to use with output ROOT objects, no odd characters
    ostringstream label;
    label << this->TgtName() << "_" << (int) 1000*fE << "_" << (int) 1000*fTheta;
    return label.str();
  }
private:
  int    fTgtPdg;   //
  string fCitation; //
  double fE;        //
  double fTheta;    //
};
//.................................................................................

//
// constants
//

// defaults
const char * kDefDataArchiveFilename = "data/validation/eA/xsec/differential/qe/eQE.root";  
const char * kDefDataSetsFilename    = "data/validation/eA/xsec/differential/qe/datasets.txt";  

// plot config
const int kNCx = 2; // number of columns in TCanvas::Divide()
const int kNCy = 2; // number of rows    in TCanvas::Divide()

// model line styles
const int kNMaxNumModels = 5;
const int kLStyle[kNMaxNumModels] = 
{
   1, 2,  3,  5, 6
};
string kLStyleTxt[kNMaxNumModels] = 
{
  "solid", "dashed", "dotted", "dot-dashed", "dot-dot-dashed"
};

//
// globals
//

string gOptDataArchiveFilename = "";    // -d argument
string gOptDataSetsFilename    = "";    // -s argument
string gOptGenieFileList       = "";    // -g argument
bool   gOptUseToyModel         = false; // --use-toy-model 
bool   gOptUseGaussianForQE    = false; // --fit-qe-peak-with-gaussian 

TFile *        gQEDataFile  = 0; // input file with expt. data
TTree *        gQEDataTree  = 0; // input tree with expt. data
TPostScript *  gOutPS       = 0; // output PS file
TFile *        gOutRF       = 0; // output ROOT file
TCanvas *      gC           = 0;
bool           gShowModel   = false;

GSimFiles gGenieInputs;

vector<eQEDataSetDescription *> gDataSets; // list of plotted datasets

//
// function prototypes
//

void             Init               (void);
void             End                (void);
TGraphErrors *   Data               (int iset);
vector<TGraph *> Model              (int iset, int imodel);
vector<TGraph *> ToyModel           (int iset, int imodel, TGraphErrors * data, vector<TGraph *> & model);
void             Draw               (int iset);
void             GetCommandLineArgs (int argc, char ** argv);
void             PrintSyntax        (void);


//_________________________________________________________________________________
int main(int argc, char ** argv)
{
  GetCommandLineArgs (argc,argv);

  Init();

  // loop over data sets and plot data and corresponding GENIE predictions
  for(unsigned int iset = 0; iset < gDataSets.size(); iset++) 
  {
    LOG("gvldtest", pNOTICE) 
      << "Producing plots for: " << gDataSets[iset]->LabelTeX();
    Draw(iset);
  }

  End();

  LOG("gvldtest", pINFO)  << "Done!";
  return 0;
}
//_________________________________________________________________________________
void Init(void)
{
  LOG("gvldtest", pNOTICE) << "Initializing...";

  // Set GENIE style
  utils::style::SetDefaultStyle();

  //
  // Get TTree with electron-scattering data
  //
  if( ! utils::system::FileExists(gOptDataArchiveFilename) ) {
      LOG("gvldtest", pFATAL) 
         << "Can not find file: " << gOptDataArchiveFilename;
      gAbortingInErr = true;
      exit(1);
  }
  gQEDataFile = new TFile(gOptDataArchiveFilename.c_str(),"read");  
  gQEDataTree = (TTree *) gQEDataFile->Get("qent");
  if(!gQEDataTree)  gQEDataTree = (TTree *) gQEDataFile->Get("resnt");
  if(!gQEDataTree) {
      LOG("gvldtest", pFATAL) 
         << "Can not find TTree `qent' or `resent' in file: " << gOptDataArchiveFilename;
      gAbortingInErr = true;
      exit(1);
  }

  //
  // Read information on which data-sets to plot
  //
  LOG("gvldtest", pDEBUG) 
    << "Reading dataset summary info from: " << gOptDataSetsFilename;
  ifstream summary_file(gOptDataSetsFilename.c_str());
  if (!summary_file.good() ) {
      LOG("gvldtest", pFATAL) 
         << "Can't open data summary file: " << gOptDataSetsFilename;
      gAbortingInErr = true;
      exit(1);
  }
  while(1) {
      // skip header lines staring with #
      if(summary_file.peek() == '#') {
         summary_file.ignore(1000, '\n');
       } else {
         int    target   = 0;
         string citation = "";
         double E        = 0;
         double theta    = 0;
         summary_file >> target >> citation >> E >> theta;
         summary_file.ignore(1000, '\n');
         if(summary_file.eof()) break;            

         LOG("gvldtest", pNOTICE) 
            << "target: " << target << ", citation: " << citation
            << ", E = " << E << " GeV, theta = " << theta << " deg";

         eQEDataSetDescription * dataset = 
                 new eQEDataSetDescription(target,citation,E,theta);
         gDataSets.push_back(dataset);
       }
  }
  summary_file.close();
  LOG("gvldtest", pNOTICE) 
     << "Read "  << gDataSets.size() << " datasets";

  // Read GENIE inputs
  if(gShowModel) {
    bool ok = gGenieInputs.LoadFromFile(gOptGenieFileList);
    if(!ok) {
       LOG("gtune", pFATAL)
         << "Could not read GENIE inputs specified in XML file: "
         << gOptGenieFileList;
       gAbortingInErr = true;
       exit(1);
    }
  }

  // Create plot canvas
  gC = new TCanvas("c","",20,20,500,650);
  gC->SetBorderMode(0);
  gC->SetFillColor(0);
  gC->SetGridx();
  gC->SetGridy();

 // Get local time to tag outputs
  string lt_for_filename   = utils::system::LocalTimeAsString("%02d.%02d.%02d_%02d.%02d.%02d");
  string lt_for_cover_page = utils::system::LocalTimeAsString("%02d/%02d/%02d %02d:%02d:%02d");

  // Create output ROOT file
  string root_filename  = Form("genie-e_qe_data_comp-%s.root",lt_for_filename.c_str());
  gOutRF = new TFile(root_filename.c_str(), "recreate");

  // Create output postscript file
  string filename  = Form("genie-e_qe_data_comp-%s.ps",lt_for_filename.c_str());
  gOutPS = new TPostScript(filename.c_str(), 111);

  // Add cover page
  gOutPS->NewPage();
  gC->Range(0,0,100,100);
  TPavesText hdr(10,40,90,70,3,"tr");
  hdr.AddText(" ");
  hdr.AddText("GENIE comparison with e QE data");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(" ");
  hdr.AddText(lt_for_cover_page.c_str());
  hdr.AddText(" ");
  hdr.Draw();
  gC->Update();
}
//_________________________________________________________________________________
void End(void)
{
  LOG("gvldtest", pNOTICE) << "Cleaning up...";

  gQEDataFile->Close();

  gOutPS->Close();
  gOutRF->Close();

  delete gC;
  delete gOutPS;
  delete gOutRF;
}
//_________________________________________________________________________________
TGraphErrors * Data(int iset)
{
  const double dE      = 2.0E-3;
  const double dtheta  = 2.5E-2;

  int    Z        = gDataSets[iset]->TgtZ();
  int    A        = gDataSets[iset]->TgtA();
  double E        = gDataSets[iset]->E();
  double theta    = gDataSets[iset]->Theta();
  string citation = gDataSets[iset]->Citation();

  const char * selection = 
    Form("E > %f && E < %f && theta > %f && theta < %f && Z == %d && A == %d",
         E     - dE,
         E     + dE,
         theta - dtheta,
         theta + dtheta,
         Z,A);

  gQEDataTree->Draw("v:xsec:xsec_err", selection, "goff");
  
  int n = gQEDataTree->GetSelectedRows();

  LOG("gvldtest", pNOTICE) 
    << "Found " << n << " data points in the xsec archive";

  if(n == 0) return 0; // return null graph

  // Data returned by TTree::Draw() are not necessarily ordered in W
  // Do the ordering here before building the graph
  int    *  idx = new int   [n];
  double *  xv  = new double[n];
  double *  yv  = new double[n];
  double *  dyv = new double[n];

  TMath::Sort(n,gQEDataTree->GetV1(),idx,false);

  for(int i=0; i<n; i++) {
     int ii = idx[i];
     xv [i] = (gQEDataTree->GetV1())[ii];
     yv [i] = (gQEDataTree->GetV2())[ii];
     dyv[i] = (gQEDataTree->GetV3())[ii];
  }

  TGraphErrors * gr = new TGraphErrors(n,xv,yv,0,dyv);
  gr->SetTitle(citation.c_str());
  utils::style::Format(gr, 1,1,1,1,8,0.8);

  delete [] idx;
  delete [] xv;
  delete [] yv;
  delete [] dyv;

  return gr;
}
//_________________________________________________________________________________
vector<TGraph *> Model(int iset, int imodel)
{
// Corresponding GENIE prediction for the `iset' data set 

  vector<TGraph *> model;

  if(!gShowModel) return model;

  LOG("gvldtest", pNOTICE) 
    << "Getting GENIE prediction (model ID = " 
    << imodel << ", data set ID = " << iset << ")";

  TFile * xsec_file = gGenieInputs.XSecFile(imodel);
  if(!xsec_file) {
     LOG("gvldtest", pFATAL)
        << "No corresponding cross section file";
     exit(1);
  }
  TChain * event_chain = gGenieInputs.EvtChain(imodel);
  if(!event_chain) {
     LOG("gvldtest", pFATAL)
        << "No corresponding event chain.";
     exit(1);
  }
  
  int    Z     = gDataSets[iset]->TgtZ();
  int    A     = gDataSets[iset]->TgtA();
  double E     = gDataSets[iset]->E();
  double theta = gDataSets[iset]->Theta();
  double costheta = TMath::Cos(kPi*theta/180.);

  double Emin        = E - 0.02;
  double Emax        = E + 0.02;
  double dcos = .03;
  if (costheta>0.98) dcos = .005;
  if (costheta>0.99) dcos = .001;
  double costhetamin = costheta - dcos;
  double costhetamax = costheta + dcos; //.03
  costhetamin = TMath::Max(-1.0, costhetamin);
  costhetamax = TMath::Min( 1.0, costhetamax);
  if (costhetamax>1.0) {
     LOG("vldtest", pFATAL)
        << "costhetamax>1 for plot- unphysical range ";
     exit(1);
  }

  // get total cross section
  PDGLibrary * pdglib = PDGLibrary::Instance();
  int tgtpdg = pdg::IonPdgCode(A,Z);
  const char * tgtname = pdglib->Find(tgtpdg)->GetName();
  const char * dirname = Form("e-_%s",tgtname);
  const char * xsec_spline_name = "tot_em";
  TDirectory * dir = (TDirectory*)xsec_file->Get(dirname);
  TGraph * xsec_em_gr = (TGraph*)dir->Get(xsec_spline_name);
  if(!xsec_em_gr) {
     LOG("vldtest", pFATAL)
        << "Null E/M cross section graph";
     exit(1);
  }
  double xsec_em = xsec_em_gr->Eval(E); 
  xsec_em *= (1E-38  * units::cm2 / units::nb); // convert to nbarn
  if(xsec_em <= 0) {
     LOG("vldtest", pFATAL)
        << "Non-positive E/M cross-section";
     exit(1);
  }
  LOG("gvldtest", pNOTICE)
    << "e- + " << tgtname << " total cross-section (E = " << E << " GeV) = " 
    << xsec_em << " nbarn";

  event_chain->Draw("1", Form("(Ev>=%f)&&(Ev<%f)&&(Z==%d)&&(A==%d)&&(em)",Emin,Emax,Z,A), "GOFF");
  double nentries_all = event_chain->GetSelectedRows();
  LOG("gvldtest", pNOTICE)
    << "Selected " << nentries_all << " MC events for E = " << E << " GeV"; 
  if(nentries_all <= 0.)  {
    return model;
  }

  int nbins = 60;
  if (E>4) nbins = 100;
  if (E>8) nbins = 200;

  double dv = E/nbins;
  double dcostheta = costhetamax-costhetamin;

  double scale = xsec_em / (2*kPi*nentries_all*dv*dcostheta);
  LOG("gvldtest", pNOTICE)
     << "Scaling factor: " << scale;

  const int ngraphs = 5;

  string select_events_in_costheta_bin[ngraphs] = {
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em)", 
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&qel)", 
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&mec)",
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&res)", 
            Emin, Emax, costhetamin, costhetamax, Z, A),
       Form("(Ev>=%f)&&(Ev<%f)&&(cthl>=%f)&&(cthl<%f)&&(Z==%d)&&(A==%d)&&(em&&(!qel&&!mec&&!res))", 
            Emin, Emax, costhetamin, costhetamax, Z, A)
  };

  string label[ngraphs] = {
      "Total", "Quasi-elastic", "Meson Exchange", "Resonance", "Other" 
  };
  int color[ngraphs] = { kBlack, kBlue,  kBlue,   kRed,   kGreen };
  int style[ngraphs] = { kSolid, kSolid, kDashed, kSolid, kSolid };
  int width[ngraphs] = { 2,      1,      2,       1,      1      };

  for(int igr = 0; igr < ngraphs; igr++) {
      TH1D * v_distribution = new TH1D("v_distribution","",nbins,0,E);
      LOG("gvldtest", pNOTICE)
         << "Applying selection: " << select_events_in_costheta_bin[igr];
      event_chain->Draw("Ev-El>>v_distribution", select_events_in_costheta_bin[igr].c_str(), "goff");      
      double nentries = event_chain->GetSelectedRows();
      LOG("gvldtest", pNOTICE)
          << "Selected " << nentries << " " << label[igr] << " events for E = " << E << " GeV"
          << " in costheta range [" << costhetamin << ", " << costhetamax << ")";     
      v_distribution->Scale(scale);
      double * v = new double[nbins]; 
      double * d2sigma_dEpdOmega = new double[nbins]; 
      for(int i=0; i<nbins; i++) {
         v[i] = v_distribution->GetBinCenter(i+1);
         d2sigma_dEpdOmega[i] = v_distribution->GetBinContent(i+1);
      }
      TGraph * gr = new TGraph(nbins,v,d2sigma_dEpdOmega);
      gr->SetTitle(label[igr].c_str());
      utils::style::Format(gr, color[igr], style[igr], width[igr], 1,1,1);
      model.push_back(gr);
      delete [] v;
      delete [] d2sigma_dEpdOmega;
      delete v_distribution;
  }//igr

  return model;
}
//_________________________________________________________________________________
vector<TGraph *> ToyModel(
  int /*iset*/, int /*imodel*/, TGraphErrors * data, vector<TGraph *> & model)
{
  vector<TGraph *> toymodel;

  if(gOptUseGaussianForQE) {
    gStyle->SetOptFit(0000);
    // \nu range of data points
    double xmin =  99999999.9;
    double xmax = -99999999.9;
    xmin  = ( data->GetX() )[TMath::LocMin(data->GetN(),data->GetX())];
    xmax  = ( data->GetX() )[TMath::LocMax(data->GetN(),data->GetX())];
    // figure out the \nu range of the QE peak to include in the fit
/*
    double E     = gDataSets[iset]->E();
    double theta = gDataSets[iset]->Theta();
    double halftheta      = 0.5*theta;
    double sinhalftheta   = TMath::Sin(kPi*halftheta/180.);
    double sinsqhalftheta = TMath::Power(sinhalftheta, 2.);
    double M = kNucleonMass;
    double v_expected = 2*E*E*sinsqhalftheta / (M+2*E*sinsqhalftheta);
*/
    // do a gaussian fit of the GENIE QE model to determine the \nu  range
    // of the QE peak and then use this range in the gaussian fit of the (e,e') data
    TGraph * genie_qe = model[1];
    genie_qe->Fit("gaus","0","",1.05*xmin,xmax);
    TF1 * fit_genie_qe = genie_qe->GetFunction("gaus");
    double mean  = fit_genie_qe->GetParameter(1);
    double sigma = fit_genie_qe->GetParameter(2);
    LOG("gvldtest", pINFO)
        << "Gaussian for of QE model: mean = " << mean << ", sigma = " << sigma;
    data->Fit("gaus","0","",1.05*xmin, mean+0.5*sigma);
    TF1 * fit = data->GetFunction("gaus");
    fit->SetRange(xmin,xmax);

    const int ngraphs = 5;

    string label[ngraphs] = {
      "Total", "Quasi-elastic (g)", "Meson Exchange", "Resonance", "Other" 
    };
    int color[ngraphs] = { kBlack, kBlue,  kBlue,   kRed,   kGreen };
    int style[ngraphs] = { kSolid, kSolid, kDashed, kSolid, kSolid };
    int width[ngraphs] = { 2,      1,      2,       1,      1      };

    const int nbins = 100;
    const double dx = (xmax-xmin)/(nbins-1);

    for(int igr = 0; igr < ngraphs; igr++) {
       double * v = new double[nbins]; 
       double * d2sigma_dEpdOmega = new double[nbins]; 
       for(int i=0; i<nbins; i++) {
         v[i] = xmin + i*dx;
         d2sigma_dEpdOmega[i] = 0;
         // in total xsec calculation, use toy QE xsec not the actual GENIE xsec
         if      (igr == 0) d2sigma_dEpdOmega[i] = model[0]->Eval(v[i]) + fit->Eval(v[i]) - model[1]->Eval(v[i]);
         // use toy QE xsec
         else if (igr == 1) d2sigma_dEpdOmega[i] = fit->Eval(v[i]);
         // for other components, use actual GENIE xsec
         else               d2sigma_dEpdOmega[i] = model[igr]->Eval(v[i]);
       }
       TGraph * gr = new TGraph(nbins,v,d2sigma_dEpdOmega);
       gr->SetTitle(label[igr].c_str());
       utils::style::Format(gr, color[igr], style[igr], width[igr], 1,1,1);
       toymodel.push_back(gr);
       delete [] v;
       delete [] d2sigma_dEpdOmega;
    }//igr
  }

  return toymodel;
}
//_________________________________________________________________________________
void Draw(int iset)
{
  // get all measurements for the current channel from the NuValidator MySQL dbase
  TGraphErrors * data = Data(iset);
  if(!data) return;

  // get the corresponding GENIE model prediction
  vector<TGraph *> gmodel = Model(iset,0);

  // get toy model
  vector<TGraph *> tmodel = ToyModel(iset,0,data,gmodel);

  vector<TGraph *> model = (gOptUseToyModel) ? tmodel : gmodel;

  int plots_per_page = kNCx * kNCy;
  int iplot = 1 + iset % plots_per_page;

  if(iplot == 1) {
     gOutPS->NewPage();
     gC -> Clear();
     gC -> Divide(kNCx,kNCy);
  }

  gC -> GetPad(iplot) -> Range(0,0,100,100);
  gC -> GetPad(iplot) -> SetFillColor(0);
  gC -> GetPad(iplot) -> SetBorderMode(0);
  gC -> GetPad(iplot) -> cd();

  //
  // draw frame
  //

  TH1F * hframe = 0;

  double xmin =  99999999.9, scale_xmin = 0.8;
  double xmax = -99999999.9, scale_xmax = 1.2;
  double ymin =  99999999.9, scale_ymin = 0.4;
  double ymax = -99999999.9, scale_ymax = 1.2;

  xmin  = ( data->GetX() )[TMath::LocMin(data->GetN(),data->GetX())];
  xmax  = ( data->GetX() )[TMath::LocMax(data->GetN(),data->GetX())];
  ymin  = ( data->GetY() )[TMath::LocMin(data->GetN(),data->GetY())];
  ymax  = ( data->GetY() )[TMath::LocMax(data->GetN(),data->GetY())];
 
  // take also into account the d2sigma/dEdOmega range in the the models
  // (for the v=E-E' range of the dataset) just in case data and MC are not that similar...
  for(unsigned int ic = 0; ic < model.size(); ic++) 
  {  
     TGraph * mm = model[ic];
     if(mm) {
       for(int k=0; k<mm->GetN(); k++) {
          double x = (mm->GetX())[k];
          if(x < xmin || x > xmax) continue;
          ymin = TMath::Min(ymin, (mm->GetY())[k]);
          ymax = TMath::Max(ymax, (mm->GetY())[k]);
       }
     }
  }
  hframe = (TH1F*) gC->GetPad(iplot)->DrawFrame(
        scale_xmin*xmin, scale_ymin*ymin, scale_xmax*xmax, scale_ymax*ymax);

  hframe->GetXaxis()->SetTitle("#nu = E-E^{'} (GeV)");
  hframe->GetYaxis()->SetTitle("d^{2}#sigma / d#Omega dE (nb/sr/GeV)");
  hframe->GetXaxis()->SetLabelFont(62);
  hframe->GetYaxis()->SetLabelFont(62);
  hframe->GetXaxis()->SetLabelSize(0.04);
  hframe->GetYaxis()->SetLabelSize(0.04);
  hframe->GetXaxis()->SetTitleSize(0.04);
  hframe->GetYaxis()->SetTitleSize(0.04);
  hframe->GetYaxis()->SetTitleOffset(1.65);
  hframe->Draw();
 
  //
  // draw expt data and GENIE predictions & add legend
  //
  TLegend * legend = new TLegend(0.55, 0.70, 0.85, 0.88);
  legend->SetLineStyle(0);
  legend->SetFillColor(0);
  legend->SetFillStyle(0);
  legend->SetTextSize(0.04);

  data->Draw("P");
  legend->AddEntry(data,data->GetTitle(),"P");
  for(unsigned int ic = 0; ic < model.size(); ic++) 
  {  
    model[ic]->Draw("L");
    legend->AddEntry(model[ic],model[ic]->GetTitle(),"L");
  }
  legend->Draw();

  // add title
  TLatex * title = new TLatex(
     scale_xmin*xmin + 0.2*(scale_xmax*xmax-scale_xmin*xmin),
    1.01*scale_ymax*ymax,gDataSets[iset]->LabelTeX().c_str());
  title->SetTextSize(0.027);
  title->Draw();

  gC->GetPad(iplot)->Update();
  gC->Update();

  // Save to output ROOT file  
  gOutRF->cd();
  gC   -> Write(Form("canvas_%s", gDataSets[iset]->LabelCompact().c_str()));
  data -> Write(Form("data_%s",   gDataSets[iset]->LabelCompact().c_str()));
  for(unsigned int ic = 0; ic < model.size(); ic++) 
  {  
     TGraph * mm = model[ic];
     if(!mm) continue;
     //
     string mlabel_compact = "";
     string mlabel = model[ic]->GetTitle();
     if      (mlabel == "Total"               ) mlabel_compact = "tot"; 
     else if (mlabel == "Quasi-elastic"       ) mlabel_compact = "qe";
     else if (mlabel == "Quasi-elastic (g)"   ) mlabel_compact = "qegaus";
     else if (mlabel == "Meson Exchange"      ) mlabel_compact = "mec";
     else if (mlabel == "Resonance"           ) mlabel_compact = "res";
     else if (mlabel == "Other"               ) mlabel_compact = "oth";
     mm -> Write(Form("genie_%s_%s", 
        gDataSets[iset]->LabelCompact().c_str(), mlabel_compact.c_str()));
  };
}
//_________________________________________________________________________________
// Parsing command-line arguments, check/form filenames, etc
//.................................................................................
void GetCommandLineArgs(int argc, char ** argv)
{
  LOG("gvldtest", pNOTICE) << "*** Parsing command line arguments";

  CmdLnArgParser parser(argc,argv);

  if(parser.OptionExists('d')){
     string filename = parser.ArgAsString('d');
     gOptDataArchiveFilename = filename;
  } else {
     if(gSystem->Getenv("GENIE")) {
        string base_dir = string( gSystem->Getenv("GENIE") );
        string filename = base_dir + "/" + kDefDataArchiveFilename;
        gOptDataArchiveFilename = filename;
     } else {
        LOG("gvldtest", pFATAL)
          << "\n Please make sure that $GENIE is defined, or use the -d option"
          << "\n You didn't specify a data file and I can not pick the default one either";
        gAbortingInErr = true;
        exit(1);
     }
  }

  if(parser.OptionExists('s')){
     string filename = parser.ArgAsString('s');
     gOptDataSetsFilename = filename;
  } else {
     if(gSystem->Getenv("GENIE")) {
        string base_dir = string( gSystem->Getenv("GENIE") );
        string filename = base_dir + "/" + kDefDataSetsFilename;
        gOptDataSetsFilename = filename;
     } else {
        LOG("gvldtest", pFATAL)
          << "\n Please make sure that $GENIE is defined, or use the -s option"
          << "\n You didn't specify a data file and I can not pick the default one either";
        gAbortingInErr = true;
        exit(1);
     }
  }

  // get GENIE inputs
  gShowModel = false;
  if( parser.OptionExists('g') ) {
     gOptGenieFileList = parser.ArgAsString('g');
     gShowModel = true;
  } 

  // construct toy model?
  if( parser.OptionExists("use-toy-model") ) {
     gOptUseToyModel = true; 
  }

  // toy model option: fit QE peak with gaussian
  if( parser.OptionExists("fit-qe-peak-with-gaussian") ) {
     gOptUseGaussianForQE = true;
  }

}
//_________________________________________________________________________________
void PrintSyntax(void)
{
  LOG("gvldtest", pNOTICE)
    << "\n\n" << "Syntax:" << "\n"
    << "  gvld_e_qel_xsec \n"
    << "        [-g input_file_list] \n"
    << "        [-d data_archive] \n"
    << "        [-s datasets_to_plot] \n"
    << "        [--use-toy-model] \n"
    << "        [--fit-qe-peak-with-gaussian] \n";
}
//_________________________________________________________________________________
